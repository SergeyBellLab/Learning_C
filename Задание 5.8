/*
 ============================================================================
 Name        : Задание 5.8
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define MAX_N 10             // Максимальный размер массива N

// Функция генерации случайного дробного числа от A до B
double generateRandom(double A, double B) {
    // Генерация случайного числа от 0 до 1 и масштабирование в диапазон [A, B]
    return A + (B - A) * ((double)rand() / RAND_MAX);
}

// Функция заполнения двумерного массива случайными числами
void fillArray(double arr[][MAX_N], int N, double A, double B) {
    int i, j;               // Локальные переменные для циклов

    // Инициализация генератора случайных чисел текущим временем
    srand(12345);

    // Двойной цикл для заполнения всех элементов массива
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            // Заполнение элемента случайным числом из диапазона [A, B]
            arr[i][j] = generateRandom(A, B);
        }
    }
}

// Функция вывода массива на экран
void printArray(double arr[][MAX_N], int N) {
    int i, j;               // Локальные переменные для циклов

    // Двойной цикл для вывода всех элементов массива
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            // Вывод элемента с 2 знаками после запятой
            printf("%.2f\t", arr[i][j]);
        }
        printf("\n");       // Переход на новую строку после вывода строки
    }
    printf("\n");           // Дополнительный перенос строки
}

// Функция поиска строки с наименьшим по модулю элементом, кратным 8
int findMinAbsMultiple8Row(double arr[][MAX_N], int N) {
    int row = -1;           // Индекс строки (-1 если не найдено)
    double minAbs = 1e9;    // Минимальное абсолютное значение (большое число)
    int i, j;               // Локальные переменные для циклов

    // Двойной цикл по всем элементам массива
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            // Проверка кратности 8 (с учетом погрешности для float)
            if (fabs(arr[i][j] - 8 * round(arr[i][j] / 8)) < 1e-6) {
                // Если абсолютное значение меньше текущего минимума
                if (fabs(arr[i][j]) < minAbs) {
                    minAbs = fabs(arr[i][j]); // Обновление минимума
                    row = i;                // Запоминание номера строки
                }
            }
        }
    }
    return row;             // Возврат номера строки
}

// Функция подсчета суммы последних четных элементов в каждой строке
double sumLastEvenElements(double arr[][MAX_N], int N) {
    double sum = 0;         // Локальная переменная для суммы
    int i, j;               // Локальные переменные для циклов

    // Цикл по всем строкам
    for (i = 0; i < N; i++) {
        // Поиск последнего четного элемента в строке
        for (j = N - 1; j >= 0; j--) {
            // Проверка четности (с учетом погрешности)
            if (fabs(arr[i][j] - 2 * round(arr[i][j] / 2)) < 1e-6) {
                sum += arr[i][j]; // Добавление к сумме
                break;          // Выход из внутреннего цикла
            }
        }
    }
    return sum;             // Возврат суммы
}

// Функция поиска максимального положительного элемента главной диагонали
double maxMainDiagonalPositive(double arr[][MAX_N], int N) {
    double maxVal = -1;     // Максимальное значение (-1 если не найдено)
    int i;                  // Локальная переменная для цикла

    // Цикл по главной диагонали (i == j)
    for (i = 0; i < N; i++) {
        // Проверка положительности элемента
        if (arr[i][i] > 1e-6) {
            // Обновление максимума
            if (arr[i][i] > maxVal) {
                maxVal = arr[i][i];
            }
        }
    }
    return maxVal;          // Возврат максимального значения
}

// Функция поиска минимального положительного элемента побочной диагонали, кратного 3
double minAntiDiagonalMultiple3(double arr[][MAX_N], int N) {
    double minVal = 1e9;    // Минимальное значение (большое число)
    int i;                  // Локальная переменная для цикла
    int found = 0;          // Флаг наличия подходящего элемента

    // Цикл по побочной диагонали (i + j == N-1)
    for (i = 0; i < N; i++) {
        int j = N - 1 - i;  // Индекс столбца для побочной диагонали
        // Проверка положительности и кратности 3
        if (arr[i][j] > 1e-6 && fabs(arr[i][j] - 3 * round(arr[i][j] / 3)) < 1e-6) {
            minVal = arr[i][j]; // Обновление минимума
            found = 1;          // Установка флага
            break;              // Выход после первого найденного
        }
    }
    // Возврат минимального значения или -1 если не найдено
    return found ? minVal : -1;
}

int main() {
    double arr[MAX_N][MAX_N];   // Локальный двумерный массив
    int N;                      // Размер массива
    double A, B;                // Диапазон генерации [A, B]
    int row;                    // Номер строки с min |el| кратным 8
    double sumEven;             // Сумма последних четных элементов
    double maxMain, minAnti;    // Элементы диагоналей
    double difference;          // Разность максимумов

    // Ввод параметров
    printf("Введите N (1-%d): ", MAX_N);
    scanf("%d", &N);            // Считывание размера массива
    printf("Введите A и B: ");
    scanf("%lf %lf", &A, &B);   // Считывание границ диапазона

    // Проверка корректности входных данных
    if (N > MAX_N || N <= 0 || A >= B) {
        printf("Некорректные входные данные!\n");
        return 1;               // Завершение программы с ошибкой
    }

    // Заполнение массива случайными числами
    fillArray(arr, N, A, B);

    // Вывод массива
    printf("\nСгенерированный массив:\n");
    printArray(arr, N);

    // Поиск строки с наименьшим по модулю элементом кратным 8
    row = findMinAbsMultiple8Row(arr, N);
    printf("Строка с наименьшим |el| кратным 8: %d\n", row);

    // Подсчет суммы последних четных элементов
    sumEven = sumLastEvenElements(arr, N);
    printf("Сумма последних четных элементов: %.2f\n", sumEven);

    // Поиск элементов диагоналей
    maxMain = maxMainDiagonalPositive(arr, N);
    minAnti = minAntiDiagonalMultiple3(arr, N);

    // Вывод результатов
    if (maxMain >= 0 && minAnti >= 0) {
        difference = maxMain - minAnti;
        printf("Max главной диагонали (%.2f) больше min побочной кратной 3 (%.2f) на %.2f\n",
               maxMain, minAnti, difference);
    } else {
        printf("Не найдены подходящие элементы на диагоналях\n");
    }

    return 0;                   // Завершение программы успешно
}

