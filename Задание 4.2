/*
 ============================================================================
 Name        : Задание 4.2
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdio.h>
#define N 5  // Размер массива 5x5 для примера
#define M 5

int main() {
    int A[N][M] = {  // Инициализация двумерного массива с отрицательными и положительными элементами
        {-16, -8, 12, -24, 5},   // Строка 0: отрицательные -16(кратно8), -8(кратно8), -24(кратно8)
        {-3, 10, -40, 7, -8},    // Строка 1: отрицательные -3(не кратно8), -40(кратно8), -8(кратно8)
        {2, -64, 15, -32, 9},    // Строка 2: отрицательные -64(кратно8), -32(кратно8)
        {-7, 4, -16, 20, -48},   // Строка 3: отрицательные -7(не кратно8), -16(кратно8), -48(кратно8)
        {6, -2, 11, 80, 3}      // Строка 4: отрицательные -2(не кратно8), 80(кратно8)
    };

    int max_neg[N];  // Одномерный массив для максимальных отрицательных элементов кратных 8 (по строкам)
    int sum_even[M]; // Одномерный массив для сумм четных элементов (по столбцам)

    // Инициализация массивов результатами "отсутствия" подходящих элементов
    for(int i = 0; i < N; i++) max_neg[i] =  -9999; //заполним заведомо большим отрицательным числом, чтобы найти потом максимальное отрицательное
    for(int j = 0; j < M; j++) sum_even[j] = 0;

    // Поиск максимального отрицательного элемента кратного 8 для каждой строки
    for(int i = 0; i < N; i++) {                   // Перебор всех строк
        for(int j = 0; j < M; j++) {               // Перебор всех элементов в текущей строке
            if(A[i][j] < 0 && A[i][j] % 8 == 0) { // Проверка: отрицательный И кратный 8
                if(A[i][j] > max_neg[i]) {         // Если текущий элемент больше найденного максимума
                    max_neg[i] = A[i][j];          // Обновляем максимум для этой строки
                }
            }
        }
    }

    // Вычисление суммы четных элементов для каждого столбца
    for(int j = 0; j < M; j++) {                   // Перебор всех столбцов
        for(int i = 0; i < N; i++) {               // Перебор всех строк в текущем столбце
            if(A[i][j] % 2 == 0) {                 // Если элемент четный
                sum_even[j] += A[i][j];            // Прибавляем к сумме столбца
            }
        }
    }

    // Вывод двумерного массива в прямоугольном виде
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            printf("%6d ", A[i][j]);               // Вывод элементов массива с выравниванием по ширине 6
        }
        if(max_neg[i] != -9999) {                 // Если элемент не дефолтный
        	printf("| %6d\n", max_neg[i]);             // Вывод максимального отрицательного кратного 8 справа от строки
         }
        else {
        	printf("| \n");
        }
    }

    // Вывод разделительной линии под массивом
    printf("       ");                              // Пробелы для выравнивания под столбцами
    for(int j = 0; j < M; j++) {
        printf("------");                          // Горизонтальная разделительная линия
    }
    printf("------\n");                             // Продолжение линии под столбец максимумов

    // Вывод массива сумм четных элементов снизу
    for(int j = 0; j < M; j++) {
        printf("%6d ", sum_even[j]);               // Вывод сумм четных элементов столбцов
    }
    //printf("| %6d\n", 0);                           // Пустое место под столбец максимумов (для симметрии)

    return 0;
}

