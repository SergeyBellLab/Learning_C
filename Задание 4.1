/*
 ============================================================================
 Name        : Задание 4.1
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

/*
 1 Образовать новый одномерный массив из отрицательных элементов исходного одномерного массива из N элементов.
   Вывести на экран исходный и получившийся массив. При создании нового массива использовать динамическую память.
 2	Образовать новый одномерный массив из элементов двумерного массива N*M.
	Элементы нового массива должны четными элементами главной и побочной диагонали исходного массива.
	Вывести на экран исходный и получившийся массив. При создании новго массива использовать динамическую память.
 */
#include <stdio.h>          // Подключаем стандартную библиотеку ввода-вывода
#include <stdlib.h>         // Подключаем библиотеку для работы с динамической памятью

int main()                  // Главная функция программы
{
    // === ПЕРВАЯ ЧАСТЬ: Работа с одномерным массивом ===

    int N;                  // Переменная для хранения размера массива
    printf("Введите размер массива N: ");    // Выводим запрос для ввода размера
    scanf("%d", &N);        // Считываем размер массива с клавиатуры

    int *arr1D = (int*)malloc(N * sizeof(int));  // Выделяем память под исходный массив из N элементов

    printf("Введите %d элементов массива:\n", N); // Запрашиваем ввод элементов массива
    for(int i = 0; i < N; i++)                   // Цикл для ввода N элементов
    {
        scanf("%d", &arr1D[i]);                  // Считываем i-й элемент массива
    }

    // Подсчитываем количество отрицательных элементов
    int neg_count = 0;                           // Счетчик отрицательных элементов
    for(int i = 0; i < N; i++)                   // Проходим по всем элементам массива
    {
        if(arr1D[i] < 0)                         // Проверяем, является ли элемент отрицательным
            neg_count++;                         // Увеличиваем счетчик отрицательных элементов
    }

    int *neg_arr = (int*)malloc(neg_count * sizeof(int)); // Выделяем память под массив отрицательных элементов

    int idx = 0;                                 // Индекс для записи в новый массив
    for(int i = 0; i < N; i++)                   // Проходим по исходному массиву
    {
        if(arr1D[i] < 0)                         // Если элемент отрицательный
            neg_arr[idx++] = arr1D[i];           // Копируем его в новый массив и увеличиваем индекс
    }

    // Выводим исходный массив
    printf("Исходный массив: ");                 // Выводим заголовок
    for(int i = 0; i < N; i++)                   // Цикл вывода всех элементов
        printf("%d ", arr1D[i]);                 // Выводим i-й элемент
    printf("\n");                                // Перевод строки

    // Выводим массив отрицательных элементов
    printf("Отрицательные элементы: ");          // Выводим заголовок
    for(int i = 0; i < neg_count; i++)           // Цикл вывода отрицательных элементов
        printf("%d ", neg_arr[i]);               // Выводим i-й отрицательный элемент
    printf("\n");                                // Перевод строки

    free(arr1D);                                 // Освобождаем память исходного массива
    free(neg_arr);                               // Освобождаем память массива отрицательных элементов

    printf("\n");                                // Пустая строка для разделения частей

    // === ВТОРАЯ ЧАСТЬ: Работа с двумерным массивом ===

    int n, m;                                    // Переменные для размеров двумерного массива
    printf("Введите размеры двумерного массива N M: "); // Запрашиваем размеры матрицы
    scanf("%d %d", &n, &m);                      // Считываем количество строк и столбцов

    // Выделяем память под двумерный массив (массив указателей)
    int **arr2D = (int**)malloc(n * sizeof(int*)); // Выделяем память под массив указателей
    for(int i = 0; i < n; i++)                   // Цикл для каждой строки
    {
        arr2D[i] = (int*)malloc(m * sizeof(int)); // Выделяем память под i-ю строку из m элементов
    }

    printf("Введите элементы матрицы %dx%d:\n", n, m); // Запрашиваем ввод элементов матрицы
    for(int i = 0; i < n; i++)                   // Цикл по строкам
    {
        for(int j = 0; j < m; j++)               // Цикл по столбцам
        {
            scanf("%d", &arr2D[i][j]);           // Считываем элемент [i][j]
        }
    }

    // Подсчитываем количество четных элементов на главной и побочной диагоналях
    int diag_count = 0;                          // Счетчик четных элементов диагоналей
    // Главная диагональ (i == j) - только если квадратная матрица или i < m
    for(int i = 0; i < n && i < m; i++)          // Проходим по главной диагонали
    {
        if(arr2D[i][i] % 2 == 0)                // Проверяем четность элемента главной диагонали
            diag_count++;                        // Увеличиваем счетчик
    }
    // Побочная диагональ (i + j == n-1) - только если квадратная матрица или j < m
    for(int i = 0; i < n; i++)                   // Проходим по строкам
    {
        int j = n - 1 - i;                       // Вычисляем индекс столбца побочной диагонали
        if(j >= 0 && j < m && arr2D[i][j] % 2 == 0) // Проверяем границы и четность
            diag_count++;                        // Увеличиваем счетчик
    }

    int *diag_arr = (int*)malloc(diag_count * sizeof(int)); // Выделяем память под массив четных диагональных элементов

    int diag_idx = 0;                            // Индекс для записи в новый массив

    // Копируем четные элементы главной диагонали
    for(int i = 0; i < n && i < m; i++)          // Проходим по главной диагонали
    {
        if(arr2D[i][i] % 2 == 0)                // Если элемент четный
            diag_arr[diag_idx++] = arr2D[i][i];  // Копируем в новый массив
    }
    // Копируем четные элементы побочной диагонали
    for(int i = 0; i < n; i++)                   // Проходим по строкам
    {
        int j = n - 1 - i;                       // Индекс столбца побочной диагонали
        if(j >= 0 && j < m && arr2D[i][j] % 2 == 0) // Проверяем границы и четность
            diag_arr[diag_idx++] = arr2D[i][j];  // Копируем в новый массив
    }

    // Выводим исходную матрицу
    printf("Исходная матрица:\n");                // Заголовок матрицы
    for(int i = 0; i < n; i++)                   // Цикл по строкам
    {
        for(int j = 0; j < m; j++)               // Цикл по столбцам
        {
            printf("%4d ", arr2D[i][j]);         // Выводим элемент с шириной 4 символа
        }
        printf("\n");                            // Перевод строки после строки матрицы
    }

    // Выводим массив четных диагональных элементов
    printf("Четные элементы диагоналей: ");      // Заголовок результата
    for(int i = 0; i < diag_count; i++)          // Цикл вывода элементов
        printf("%d ", diag_arr[i]);              // Выводим i-й элемент
    printf("\n");                                // Перевод строки

    // Освобождаем память двумерного массива
    for(int i = 0; i < n; i++)                   // Цикл по всем строкам
        free(arr2D[i]);                          // Освобождаем память i-й строки
    free(arr2D);                                 // Освобождаем массив указателей
    free(diag_arr);                              // Освобождаем память результирующего массива

    printf("Память освобождена успешно.\n");     // Подтверждение освобождения памяти

    return 0;                                    // Завершаем программу успешно
}

